# GO
## 变量[]
### 声明表达式
### 定义表达式（声明表达式+内存分配+[赋值表达式]）
**※变量定义前必须先声明，所以变量的定义是一个复合表达式，变量的定义必定包含了声明**
> 定义变量即明确identifier类型并在内存上关联一段空间，依据对空间的使用方式，定义分为两种
1. 直接使用空间，identifier的值为空间中即存的脏值
2. 整理空间后使用
    - 编译器清零空间（表现为自动赋初值）
    - 手动修改空间（使用赋值表达式赋初值）

**※短变量定义**
> 仅在函数中使用，变量的类型由表达式类型决定,如函数表达式则变量类型同函数返回值类型，如果需要声明与表达式类型不符的变量类型，或者声明变量后不希望立刻赋值则使用var声明
```go
var f float64 = 64 // float
f := 64 // int
```
在作用域内对同一个变量进行短变量定义则不会分配新的内存空间，而视为对原先变量的赋值
短变量定义时至少存在一个新变量
```go
in,err := os.Open(file)
out,err := os.Create(file) // 使用同一个err
in,err := os.Open(another) // 错误:无新变量
```

### 赋值表达式
#### 列表赋值
```go
var x,y int
x,y = 1,2
var z int = 3
x,y = y,x
medals := []string{"gold","silver","bronze"} // 数组定义
```
#### 构造器赋值
#### 函数表达式赋值
```go
f,err = os.Open("main.go")
f,_ = os.Open("main.go")
```
#### 隐式赋值
```go
add(1,2)
func add(a int,b int)  {
  // 相当于a = 1,b = 2
}
```
## 常量
### 无类型常量
## 值类型
### 值类型转换
### lvalue
> 左值指明一个函数或对象。举例而言，如果E是指针类型的表达式，那么*E就是指向了对象或函数的一个左值。另一个例子是，调用一个返回值是左值的结果依旧是一个左值。
### glvalue
>  generalized lvalue, 是指更泛化意义上的左值，包含了以前的一部分右值。即lvalue和xvalue的集合。
### xvalue
> 它也指向一个对象，通常已经接近了它生存期的结束。（这样一来，它的资源即将被移动）xvalue是包含了右值引用特定类型表达式的结果。（例子：调用返回值为右值引用的结果是一个xvalue）
### rvalue
> 可以是一个xvalue, 一个临时对象，或临时对象的子对象，或者是一个没有和对象关联的值
> ```go
> func newInt() *int{
>   var dummy int
>   return &dummy
> }
> ```
### prvalue
> pure right value, 纯右值，即不是xvalue的rvalue (举例：调用函数返回值并不是引用类型的结果是一个纯右值。字面量12.7， 3e5, 或者true, 都是纯右值。)
## 数据类型
### 数据类型转换
### 定义类型
**※类型定义通常出现于包级别，在整个包内可见，如果名字开头大写，说明这个类型是导出的，定义的类型即使底层具有相同类型，但是名称不同视为不同类型，使用时需要显示转换**
```go
type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZero Celsius = -273.15
	FreezingC    Celsius = 0
	BoilingC     Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}

// 类型不匹配错误，右侧F-C不匹配
var f float64 = CToF(BoilingC) - AbsoluteZero
// 类型不匹配错误，左侧接收类型不匹配
var f float64 = BoilingC - AbsoluteZero
// 自定义类型可以和底层类型运算，返回值为自定义类型
var f Celsius = BoilingC - 64
if BoilingC > 0 {}
```
### 指针
**※指针是一种特殊的整形，值为一个指向某种类型变量的地址，对变量的使用通常使用变量名，但不是所有的变量都有变量名，如数组中变量名仅表示第一个变量，后续变量需要通过对指针的算术操作求得**

**※指针别名就是一个变量的地址被其他变量拥有**
` var ip *int = &b` **ip为指针变量，也是变量b的指针别名，*ip为变量b的别名，指针变量彼此通过赋值交换变量b的指针会导致变量b的别名增加**
### 右值引用
**※保存右值的引用（指针），和声明一个局部变量再取址赋值其他变量唯一的区别就是该变量没有真名只有别名，因此节约了一个标识符**
```go
var p *int = new(int) // 在内存上分配int尺寸的空间并将地址保存在指针变量p中
```
### 左值引用
## 生命周期&作用域
### 生命周期
**※生命周期是一个运行时属性，变量一般存在三个位置，栈、堆、数据段，声明周期的结束意味着变量不可访问，变量不可访问不表示变量声明周期结束**
> ```go
> var i int = 2 // i:0x1000
> var ip *int = &i
> // 0x1000 : /i/ /ip/*/
> // 当符号i和ip/*下引用的地址都不是0x1000时可以说0x1000已不可达
> ```

|      | 开始 | 结束 |
| ---- | ---- | ---- |
| 包变量 | 程序开始 | 程序结束 |
| 局部变量 | 函数开始 | 函数结束 |
| 块变量 | 块开始 | 块结束 |

### 作用域
**作用域是编译时属性，表现为变量名的可见性**
## 函数
### 函数声明表达式
### 函数声明表达式+函数定义表达式
## 模块
### 文件
### 包
### 命名空间
